# 如何提交 PIP2001 区块？
这篇教程会给你介绍 PIP2001 都有哪些区块？作用是什么？如何提交？

## 能不能简单总结一下，开发者账户和 Dapp 自身的用户之间，是什么关系？
1. 你在 PRS 链上注册了一个开发者账户（上一步已经注册好了）
2. 假设你的应用有 1000 个用户，那么你需要给这 1000 个用户分别注册一个链上账户
3. 你用开发者账户，帮每个用户代签文章、发布区块
4. 所有上链的费用，都由开发者账户承担

## 那我的用户就不需要支付上链费用？
对，因为让每个用户都支付上链费用是不现实的，这就相当于要求所有用户，在发文章之前，都得先有 PRS 才能上链，这就提高了门槛。

所以我们建议用代签的模式。开发者垫付 PRS 上链费用，然后你可以根据产品的需要，向用户进行二次收费。

<!-- TODO: 也说一下注册用户钱包 -->

## 能不能给一个业务场景例子？
1. 用户在你的应用注册登录，你就给 Ta 创建一个链上账户，然后为 Ta 发送一个【授权区块】，允许 Ta 可以向你的站点提交文章
2. 用户发布文章，就是提交一个【新建文章区块】
3. 用户如果要修改文章，就是提交一个【修改文章区块】
4. 用户如果要删除文章，就是提交一个【删除文章区块】
5. 如果用户发布很多不合适的内容，那就提交一个【取消授权区块】，把用户的内容从站点中剔除

下面我们根据上面的业务场景，一步一步使用 `prs-atm` 这个库来提交各种区块。
## 给应用的用户注册链上账户
```javascript
const prsAtm = require("prs-atm");
(async () => {
  const accountKeystorePassword = '94235cf6327adb82';
  const keystore = await prsAtm.wallet.createKeystore(accountKeystorePassword);
  const {
    publickey,
    privatekey
  } = prsAtm.wallet.recoverPrivateKey(accountKeystorePassword, keystore);
  const freeAccount = await prsAtm.atm.openFreeAccount(publickey, privatekey);
  console.log({
    publicKey: publickey,
    privateKey: privatekey,
    address: freeAccount.account
  });
})();
```
```javascript
{
  account: "prs.1hn.2",
  publicKey: "EOS8J2hEPmauYx4L1raDRuNP6jJ1DjnVubfA4ZGyARM8qCgFHj1DV",
  privateKey: "5KRnuqJSCk1wvuDoRCN4kBrUhaeGgmqmMb5GH5wXFzH96w5mrfL"
}
```
<!-- #  TODO: 使用真实的数据 -->

你需要把这 3 个数据保存到用户的数据中，当用户需要发布区块时，就需要使用这些数据，来完成签名操作。

privateKey 建议不要明文保存在数据库中，可以加密后保存。

## 授权区块，允许一个用户向你的站点提交文章
接下来，我们给这个用户发布一个授权区块，允许它给你的站点提交文章

我们把上面产生的开发者账号，用户账号都临时保存到一个变量里面，方便接下来演示
```javascript
const developer = {
  account: "prs.1hn.2",
  publicKey: "EOS8J2hEPmauYx4L1raDRuNP6jJ1DjnVubfA4ZGyARM8qCgFHj1DV",
  privateKey: "5KRnuqJSCk1wvuDoRCN4kBrUhaeGgmqmMb5GH5wXFzH96w5mrfL"
}
const user = {
  account: "prs.1hn.2",
  publicKey: "EOS8J2hEPmauYx4L1raDRuNP6jJ1DjnVubfA4ZGyARM8qCgFHj1DV",
  privateKey: "5KRnuqJSCk1wvuDoRCN4kBrUhaeGgmqmMb5GH5wXFzH96w5mrfL"
}
```

```javascript
const prsAtm = require("prs-atm");
(async () => {
  const payload = {
    type: 'PIP:2001',
    meta: {},
    data: {
      allow: user.account,
      topic: developer.account
    }
  }
  const resp = await prsAtm.prsc.signSave(
    payload.type,
    payload.meta,
    payload.data,
    developer.account,
    developer.publicKey,
    developer.privateKey,
    {
      userAddress: developer.account,
      privateKey: developer.privateKey
    }
  );
  const blockData = resp.processed.action_traces[0].act.data;
  const block = {
    id: blockData.id,
    user_address: blockData.user_address,
    type: blockData.type,
    meta: blockData.meta,
    data: blockData.data,
    hash: blockData.hash,
    signature: blockData.signature,
    blockNum: null,
    blockTransactionId: resp.transaction_id
  };
  console.log(block);
})();
```

TODO: 例子链接
TODO: 截图

## 解除授权区块，禁止一个用户向你的站点提交文章
和授权区块基本一样，唯一不同的是把 `allow` 改成 `deny`

```javascript
const prsAtm = require("prs-atm");
(async () => {
  const payload = {
    type: 'PIP:2001',
    meta: {},
    data: {
      deny: user.account,
      topic: developer.account
    }
  }
  const resp = await prsAtm.prsc.signSave(
    payload.type,
    payload.meta,
    payload.data,
    developer.account,
    developer.publicKey,
    developer.privateKey,
    {
      userAddress: developer.account,
      privateKey: developer.privateKey
    }
  );
  const blockData = resp.processed.action_traces[0].act.data;
  const block = {
    id: blockData.id,
    user_address: blockData.user_address,
    type: blockData.type,
    meta: blockData.meta,
    data: blockData.data,
    hash: blockData.hash,
    signature: blockData.signature,
    blockNum: null,
    blockTransactionId: resp.transaction_id
  };
  console.log(block);
})();
```
TODO: 数据结构解释
TODO: 例子
TODO: 例子链接
TODO: 截图

## 新建文章区块
```javascript
const prsAtm = require("prs-atm");
(async () => {
  const fileContent = 'hello world';
  const payload = {
    type: 'PIP:2001',
    meta = {
      uris: ['https://zuopin.xin/api/storage/xxx.md'],
      mime: `text/markdown;charset=UTF-8`,
      encryption: 'aes-256-cbc',
      payment_url: `mixin://transfer/${mixinWalletClientId}`,
    },
    data: {
      file_hash: prsAtm.encryption.hash(fileContent),
      topic: developer.account
    }
  }
  const resp = await prsAtm.prsc.signSave(
    payload.type,
    payload.meta,
    payload.data,
    developer.account,
    developer.publicKey,
    developer.privateKey,
    {
      userAddress: user.account,
      privateKey: user.privateKey
    }
  );
  const blockData = resp.processed.action_traces[0].act.data;
  const block = {
    id: blockData.id,
    user_address: blockData.user_address,
    type: blockData.type,
    meta: blockData.meta,
    data: blockData.data,
    hash: blockData.hash,
    signature: blockData.signature,
    blockNum: null,
    blockTransactionId: resp.transaction_id
  };
  console.log(block);
})();
```
TODO: 数据结构解释
TODO: 例子
TODO: 例子链接
TODO: 截图

如果我的内容是私密的、或者是需要付费才能阅读的，我不想把明文公开发布到区块上面。我可以先加密内容，然后把加密后的文章发布到链上吗？

## 修改文章区块
TODO: 数据结构解释
TODO: 例子
TODO: 例子链接
TODO: 截图

## 删除文章区块
TODO: 数据结构解释
TODO: 例子
TODO: 例子链接
TODO: 截图

## 如果一个用户发布了敏感内容，想要禁止Ta，怎么做呢？
给他提交一个【解除授权区块】


## 为什么要同步地写数据库？
之所以推荐要同步写数据库，是为了让用户可以第一时间完成操作，而不用去等区块上链。整个上链和同步的过程，对于用户发布文章、修改文章最好是无感知的。用户就是在使用传统的写作产品一样。只是在需要用到区块交易，用户才需要等待上链完成，其他情况是没有必要等的。